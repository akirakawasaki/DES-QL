# standard libraries
import socket 
import decimal

# third-party libraries
import numpy as np
import pandas as pd

# local libraries
# n/a


class tlm():
    
    W2B = 2

    NUM_OF_FRAMES = 8

    LEN_HEADER  = 4
    LEN_PAYLOAD = 64
    
    BUFSIZE = W2B * (LEN_HEADER + LEN_PAYLOAD) * NUM_OF_FRAMES       # 1088 bytes
    #BUFSIZE = 1088
    #BUFSIZE = 1280
    #BUFSIZE = 2176
    
    def __init__(self, tlm_type):
        #self.HOST = socket.gethostname()
        self.HOST = ''
        self.TLM_TYPE = tlm_type

        #print(self.TLM_TYPE)
        #print(self.BUFSIZE)

        #PORT = 70
        if self.TLM_TYPE == 'smt':
            PORT = 49157
        elif self.TLM_TYPE == 'pcm':
            PORT = 49158
        else:
            print('Error: Type of the telemeter is wrong!')

        #print(PORT)

        # create a scoket for UPD/IP communication
        self.udpSoc = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        
        # bind a port
        self.udpSoc.bind((self.HOST, PORT))

        # load configuration
        if self.TLM_TYPE == 'smt':
            self.df_cfg = pd.read_excel('./config_tlm.xlsx', sheet_name='smt')
        elif self.TLM_TYPE == 'pcm':
            self.df_cfg = pd.read_excel('./config_tlm.xlsx', sheet_name='pcm')

        self.NUM_OF_ITEMS = len(self.df_cfg.index)
        self.SUP_COM      = self.df_cfg['sup com'].max()
        
        # configure output file
        self.df = pd.DataFrame(index=[], columns=self.df_cfg['item']) 
        
        # initialize data index
        self.iData = 0

    def __del__(self):
        self.udpSoc.close()

    def save(self):
        if self.TLM_TYPE == 'smt':
            self.df.to_excel('./data.xlsx', sheet_name='smt')
        elif self.TLM_TYPE == 'pcm':
            self.df.to_excel('./data.xlsx', sheet_name='pcm')

    def receive(self):
        #print('tlm.receive called')
        self.data, self.addr = self.udpSoc.recvfrom(self.BUFSIZE)

    def reshape(self):
        # sweep frames in a major frame
        for iFrame in range(self.NUM_OF_FRAMES):
            #print(f"iData: {self.iData}")
            
            # initialize the row by filling wit NaN
            self.df.loc[self.iData] = np.nan

            adrs_tmp = iFrame * self.W2B * (self.LEN_HEADER + self.LEN_PAYLOAD)
            #print(f"adrs_tmp: {adrs_tmp}")
            
            # GSE days from January 1st 
            adrs = adrs_tmp + self.W2B * 0
            self.df.iat[self.iData,0] =  (self.data[adrs]   >> 4  ) * 100 \
                                       + (self.data[adrs]   & 0x0F) * 10  \
                                       + (self.data[adrs+1] >> 4  ) * 1
    
            # GSE timestamp in [sec]
            adrs = adrs_tmp + self.W2B * 0
            self.df.iat[self.iData,1] =  (self.data[adrs+1] & 0x0F) * 10  * 3600 \
                                       + (self.data[adrs+2] >> 4  ) * 1   * 3600 \
                                       + (self.data[adrs+2] & 0x0F) * 10  * 60   \
                                       + (self.data[adrs+3] >> 4  ) * 1   * 60   \
                                       + (self.data[adrs+3] & 0x0F) * 10         \
                                       + (self.data[adrs+4] >> 4  ) * 1          \
                                       + (self.data[adrs+4] & 0x0F) * 100 / 1000 \
                                       + (self.data[adrs+5] >> 4  ) * 10  / 1000 \
                                       + (self.data[adrs+5] & 0x0F) * 1   / 1000 
    
            # frame counter generated by the telemeter
            #adrs = adrs_tmp + self.W2B * (self.LEN_HEADER + 32)
            #self.df.iat[self.iData,2] =  self.data[adrs]   * 2**8 \
            #                           + self.data[adrs+1]
            
            # pick up data from the datagram
            for iItem in range(2, self.NUM_OF_ITEMS):
                if self.df_cfg.at[iItem,'w assgn'] < 0: continue    # skip
                
                # designate byte addres with the datagram
                adrs = adrs_tmp + self.W2B * (self.LEN_HEADER + self.df_cfg.at[iItem,'w assgn'])

                # frame/loop counter
                if self.df_cfg.at[iItem,'type'] == 'counter':
                    #self.df.iat[self.iData,iItem] = int.from_bytes(self.data[adrs], self.data[adrs+1], byteorder='big', signed=False)
                    self.df.iat[self.iData,iItem] =  self.data[adrs]   * 2**8 \
                                                   + self.data[adrs+1]
                
                # DES timestamp in [sec]
                elif self.df_cfg.at[iItem,'type'] == 'des time':
                    #self.df.iat[self.iData,iItem] = \
                    #    int.from_bytes((self.data[adrs],self.data[adrs+1],self.data[adrs+2],self.data[adrs+3]), byteorder='big', signed=False)
                    self.df.iat[self.iData,iItem] = (  self.data[adrs]   * 2**(24) \
                                                     + self.data[adrs+1] * 2**(16) \
                                                     + self.data[adrs+2] * 2**(8)  \
                                                     + self.data[adrs+3] * 2**(0)  ) / 1000.0

                # pressure in [MPa]
                elif self.df_cfg.at[iItem,'type'] == 'p':
                    self.df.iat[self.iData,iItem] =  \
                          self.df_cfg.at[iItem,'coeff a'] / float(2**11) \
                            * int.from_bytes((self.data[adrs], self.data[adrs+1]), byteorder='big', signed=True) \
                        + self.df_cfg.at[iItem,'coeff b']

                    #self.df.iat[self.iData,iItem] =  \
                    #      float(self.df_cfg.at[iItem,'coeff a']) \
                    #        * float((self.data[adrs] & 0x7F) * 2**8 + self.data[adrs+1]) / float(2**10) \
                    #    + float(self.df_cfg.at[iItem,'coeff b'])
                    
                    #dTmp =  (-(self.data[adrs] & 0b10000000) | (self.data[adrs]   & 0b01111111) ) * 2**8 \
                    #      + (                                   self.data[adrs+1] & 0b11111111  )
                    #self.df.iat[self.iData,iItem] =  \
                    #      float(self.df_cfg.at[iItem,'coeff a']) * float(dTmp) / float(2**15) * 10.0 \
                    #    + float(self.df_cfg.at[iItem,'coeff b'])
                                    
                # temperature in [uV]
                elif self.df_cfg.at[iItem,'type'] == 'T':
                    self.df.iat[self.iData,iItem] = \
                          self.df_cfg.at[iItem,'coeff a'] \
                            * int.from_bytes((self.data[adrs], self.data[adrs+1]), byteorder='big', signed=True) \
                        + self.df_cfg.at[iItem,'coeff b']

                    #self.df.iat[self.iData,iItem] = \
                    #      self.df_cfg.at[iItem,'coeff a'] / float(2**18) * 1000000.0 \
                    #        * int.from_bytes((self.data[adrs], self.data[adrs+1]), byteorder='big', signed=True) \
                    #    + self.df_cfg.at[iItem,'coeff b']

                    #self.df.iat[self.iData,iItem] = \
                    #      self.df_cfg.at[iItem,'coeff a'] / 2.0**(13) \
                    #        * int.from_bytes(self.data[adrs:adrs+1], byteorder='big', signed=True) \
                    #    + self.df_cfg.at[iItem,'coeff b']

                    #self.df.iat[self.iData,iItem] =  \
                    #      float(self.df_cfg.at[iItem,'coeff a']) \
                    #        * float((self.data[adrs] & 0x7F) * 2**8 + self.data[adrs+1]) / float(2**13) \
                    #    + float(self.df_cfg.at[iItem,'coeff b'])

                # auto zero in [uV]
                elif self.df_cfg.at[iItem,'type'] == 'az':
                    self.df.iat[self.iData,iItem] = \
                          self.df_cfg.at[iItem,'coeff a'] \
                            * int.from_bytes((self.data[adrs], self.data[adrs+1]), byteorder='big', signed=True) \
                        + self.df_cfg.at[iItem,'coeff b']

                    #self.df.iat[self.iData,iItem] = \
                    #      self.df_cfg.at[iItem,'coeff a'] / float(2**18) * 1000000.0  \
                    #        * int.from_bytes((self.data[adrs], self.data[adrs+1]), byteorder='big', signed=True) \
                    #    + self.df_cfg.at[iItem,'coeff b']

                # cold-junction compensation (binary)
                elif self.df_cfg.at[iItem,'type'] == 'cjc':
                    self.df.iat[self.iData,iItem] = \
                          self.df_cfg.at[iItem,'coeff a'] \
                            * int.from_bytes((self.data[adrs], self.data[adrs+1]), byteorder='big', signed=True) \
                        + self.df_cfg.at[iItem,'coeff b']

                # analog pressure in [MPa]
                elif self.df_cfg.at[iItem,'type'] == 'p ana':
                    if iFrame % self.df_cfg.at[iItem,'sub com mod'] != self.df_cfg.at[iItem,'sub com res']: continue
                    
                    self.df.iat[self.iData,iItem] =  \
                          self.df_cfg.at[iItem,'coeff a'] * 5.0 / float(2**16) \
                            * int.from_bytes((self.data[adrs],self.data[adrs+1]), byteorder='big', signed=True) \
                        + self.df_cfg.at[iItem,'coeff b']

                # voltage in [V]
                elif self.df_cfg.at[iItem,'type'] == 'V':
                    self.df.iat[self.iData,iItem] =  \
                          self.df_cfg.at[iItem,'coeff a'] \
                            * int.from_bytes((self.data[adrs],self.data[adrs+1]), byteorder='big', signed=True) \
                        + self.df_cfg.at[iItem,'coeff b']

                # relay status (boolean)
                elif self.df_cfg.at[iItem,'type'] == 'rel':
                    #self.df.iat[self.iData,iItem] = int.from_bytes((self.data[adrs],self.data[adrs+1]), byteorder='big', signed=False)
                    self.df.iat[self.iData,iItem] = \
                        (self.data[adrs + self.df_cfg.at[iItem,'coeff b']] & int(self.df_cfg.at[iItem,'coeff a'])) \
                            / self.df_cfg.at[iItem,'coeff a']

                # others
                else:
                    self.df.iat[self.iData,iItem] = \
                          self.df_cfg.at[iItem,'coeff a'] \
                            * int.from_bytes((self.data[adrs], self.data[adrs+1]), byteorder='big', signed=False) \
                        + self.df_cfg.at[iItem,'coeff b']

            self.iData += 1


#--- MAIN PROCEDURE STARTS HERE ------------------------------
print('DES-QL Launched!')
print('')

### STEP 0: initialize 
smt = tlm('smt')
#smt = tlm('pcm')
#pcm = tlm('pcm')

NNN = 0
#while NNN < 1:
#while NNN <= 500:
while NNN <= 30000:
    ### STEP 1: data receive
    smt.receive()

    # for debug
    '''
    print(f"From: {smt.addr}")
    print(f"To  : {socket.gethostbyname(smt.HOST)}")
    print('')
    '''
    
    '''
    for i in range(smt.NUM_OF_FRAMES):
        adrs_tmp = i * smt.W2B * (smt.LEN_HEADER + smt.LEN_PAYLOAD)

        # header
        print(f"message {i}-H: ",end='') 
        for k in range(smt.W2B * smt.LEN_HEADER): 
            print(hex(smt.data[k + adrs_tmp]).zfill(4), end=' ')
        print('')

        # payload
        for j in range(4):
            print(f"message {i}-{j}: ",end='')
            for k in range(smt.W2B * int(smt.LEN_PAYLOAD / 4)): 
                print(hex(smt.data[k + adrs_tmp + smt.W2B * (smt.LEN_HEADER + j * int(smt.LEN_PAYLOAD / 4))]).zfill(4), end=' ')
            print('')
    print('')
    '''

    #for k in range(smt.BUFSIZE):
    #    print(hex(smt.data[k]))

    #print(f"SUP_COM: {smt.SUP_COM}")
    #print('')


    ### STEP 2: data reshape
    smt.reshape()

    # for debug
    #print(smt.df)


    ### STEP 3: data save
    #if NNN % 1 == 0:
    #if NNN % 100 == 0:
    if NNN % 500 == 0:
        print(f"NNN : {NNN}")
        print(f"From: {smt.addr}")
        print(f"To  : {socket.gethostbyname(smt.HOST)}")
        print('')
        print(smt.df)
        smt.save()


    ### STEP 4: data display
    # N/A

    NNN += 1


### STEP F: finalize
del smt
#del pcm























